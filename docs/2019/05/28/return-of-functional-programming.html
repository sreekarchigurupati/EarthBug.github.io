<!DOCTYPE html> <html lang="en"> <link rel="shortcut icon" href="/favicon.png" type="image/png"> <link rel="icon" href="/favicon.png" type="image/png"> <style type=text/css> html { -webkit-filter: invert(0%); filter: invert(0%); transition: opacity 1s; } html.dark { -webkit-filter: invert(100%); filter: invert(100%); background: black} html.dark img {-webkit-filter: invert(100%); filter: invert(100%); background-color: white;} html.dark svg {-webkit-filter: invert(100%); filter: invert(100%); background-color: white} html.dark svg.svg-icon {background-color: transparent !important; } html.dark svg.svg-icon svg {background-color: transparent !important; } html.dark svg.up-icon {-webkit-filter: invert(0%) ! important; filter: invert(0%) !important; background-color: transparent !important;} </style><head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 --> <title>The return of functional programming | Musings and digressions</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="The return of functional programming" /> <meta name="author" content="Sreekar Chigurupati" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="But first ‚Ä¶ What is functional programming ? Functional programming is a programming paradigm in which most computation is treated as evaluation of functions. It emphasizes on expression evaluation instead of command execution. ‚Äì Wikipedia When did it all start ? In the 90‚Äôs, there was a war between declarative programming and imperative programming. Declarative programming then represented by logic programming languages like Prolog and early functional languages like Erlang. And imperative languages were represented by procedural languages like C and object-oriented languages like Perl. These used abstract data types and procedures (sequence of commands) to compute. You can infer, no doubt that imperative languages won, given the present state of computer languages. One big reason for this is that the process of writing code in an imperative fashion closely mimics the way programs are executed inside the computer. The theoretical basis of the modern computer being the von Neumann computer. Image by Kapooht - Own work, CC BY-SA 3.0, Link As you can see, the von Neumann model is closely mimicked by the execution flow in imperative languages. There is a strong correspondence between mutable variables and memory cells, variable dereferences and load instructions, variable assignments and store instructions, control structures and jumps. This sort of intuition helped programmers adopt them faster. What changed? It‚Äôs time to remember a legend. Gordon Moore. He observed that the number of components on a dense integrated circuit doubles every year. Moore‚Äôs Law Image by Wgsimon - Own work, CC BY-SA 3.0, Link Over the past few years, the trend has subsided as controlling the current flow in the thin channel is becoming more difficult. We cannot make chips smaller anymore, unless there are revolutionary advancements in technology. To keep up with the growing demand for computer power, we‚Äôll have to add more cores on a chip or use more chips. Huge volume workloads that require horizontal scaling are becoming more common. So we‚Äôll have to write software that better gels with the hardware we have. There are two facets to this problem Parallel programming Concurrent programming Parallel programming means using multiple units of hardware to compute something and speed up the process. But the program itself doesn‚Äôt require this, it can still be solved on a single unit of hardware without any loss of functionality apart from speed. Concurrent programming refers to programs that are inherently concurrent - multiple processes executing at the same time, that need to process large number of requests. Eg. Twitter. This has to be done in real-time and cannot be done in a sequential way. While using conventional / imperative programming to implement either of these, we face some fundamental problems. The root of the problem let‚Äôs look at some pseudocode now var x = 0 async { x = x + 1 } async { x = x * 2 } // can give 0, 1, 2 The above program has two asynchronous operations running. We can see that the output is non-deterministic. This non-determinism is caused by concurrent threads accessing shared mutable state. non-determinism = parallel processing + mutable state Out of these, parallel processing can‚Äôt be avoided as our processors aren‚Äôt growing anytime soon. Hence we have to avoid mutable state. The Solution Here come in functional programming and pure functions. When is a function pure? It returns the same result if given the same arguments (it is also referred to as deterministic) It does not cause any observable side effects So functions that use global objects for example would be impure functions. In functional programming, the programmer would no longer have to worry about manually iterating values or accessing the elements of a data structure. All those would be hidden away in a declarative expression. This is so helpful that the imperative languages have now picked up some style in their syntax from this. Example: two ways of iterating in Java. The second line is the modern form of expression for ( int i = 0 ; i &lt; list.size ( ) ; ++i ) { doSomethingWith ( list.get ( i ) ) ; } for ( SomeType s : list ) { doSomethingWith ( s ) ; } With programs made mostly of pure functions, there‚Äôll be less mutable state to deal with. We can now think in terms of function compositions. Making one function out of others, this is sort of like thinking in terms of space, whereas imperative programming is thinking in terms of time. You don‚Äôt have to worry about concurrent accesses in the functional example, as for each request, it can be served by it‚Äôs own space, without worrying about affecting others. No need to worry about race conditions, deadlocks etc. Example : Scala A simple example in Scala of how easy it is to parallelize stuff in modern functional languages with built-in functionality for parallelism. This code separates a list of people into minors and adults. val people: Array[Person] val (minors, adults) = people partition (_.age &lt; 18) Now the same code parallelized val people: Array[Person] val (minors, adults) = people.par partition (_.age &lt; 18) That‚Äôs it. No worrying about writing the parallelization code, locks, software transactional memory YADA YADA The Functional Renaissance This fundamental compatibility in building concurrent programs has brought back functional programming into the limelight. Now we also have languages that play to the strengths of both the paradigms (Scala). The brevity achieved while writing programs in the recursive way also helps. Done! üéâ Additional resources Martin Odersky, ‚ÄúWorking Hard to Keep It Simple‚Äù - OSCON Java 2011 John Backus‚Äôs Turing Award Lecture John Backus‚Äôs Turing Award Lecture was a watershed for the programming-language community because the inventor of FORTRAN, which was the dominant programming language of the day, stepped forward and said that the main stream of programming practice was flowing in a most unproductive direction. His lecture ‚ÄúCan Programming Be Liberated From the von Neumann Style?‚Äù lambda-the-ultimate Good blog on programming language design FUN FACT Any function that relies on a random number generator cannot be pure ü§î" /> <meta property="og:description" content="But first ‚Ä¶ What is functional programming ? Functional programming is a programming paradigm in which most computation is treated as evaluation of functions. It emphasizes on expression evaluation instead of command execution. ‚Äì Wikipedia When did it all start ? In the 90‚Äôs, there was a war between declarative programming and imperative programming. Declarative programming then represented by logic programming languages like Prolog and early functional languages like Erlang. And imperative languages were represented by procedural languages like C and object-oriented languages like Perl. These used abstract data types and procedures (sequence of commands) to compute. You can infer, no doubt that imperative languages won, given the present state of computer languages. One big reason for this is that the process of writing code in an imperative fashion closely mimics the way programs are executed inside the computer. The theoretical basis of the modern computer being the von Neumann computer. Image by Kapooht - Own work, CC BY-SA 3.0, Link As you can see, the von Neumann model is closely mimicked by the execution flow in imperative languages. There is a strong correspondence between mutable variables and memory cells, variable dereferences and load instructions, variable assignments and store instructions, control structures and jumps. This sort of intuition helped programmers adopt them faster. What changed? It‚Äôs time to remember a legend. Gordon Moore. He observed that the number of components on a dense integrated circuit doubles every year. Moore‚Äôs Law Image by Wgsimon - Own work, CC BY-SA 3.0, Link Over the past few years, the trend has subsided as controlling the current flow in the thin channel is becoming more difficult. We cannot make chips smaller anymore, unless there are revolutionary advancements in technology. To keep up with the growing demand for computer power, we‚Äôll have to add more cores on a chip or use more chips. Huge volume workloads that require horizontal scaling are becoming more common. So we‚Äôll have to write software that better gels with the hardware we have. There are two facets to this problem Parallel programming Concurrent programming Parallel programming means using multiple units of hardware to compute something and speed up the process. But the program itself doesn‚Äôt require this, it can still be solved on a single unit of hardware without any loss of functionality apart from speed. Concurrent programming refers to programs that are inherently concurrent - multiple processes executing at the same time, that need to process large number of requests. Eg. Twitter. This has to be done in real-time and cannot be done in a sequential way. While using conventional / imperative programming to implement either of these, we face some fundamental problems. The root of the problem let‚Äôs look at some pseudocode now var x = 0 async { x = x + 1 } async { x = x * 2 } // can give 0, 1, 2 The above program has two asynchronous operations running. We can see that the output is non-deterministic. This non-determinism is caused by concurrent threads accessing shared mutable state. non-determinism = parallel processing + mutable state Out of these, parallel processing can‚Äôt be avoided as our processors aren‚Äôt growing anytime soon. Hence we have to avoid mutable state. The Solution Here come in functional programming and pure functions. When is a function pure? It returns the same result if given the same arguments (it is also referred to as deterministic) It does not cause any observable side effects So functions that use global objects for example would be impure functions. In functional programming, the programmer would no longer have to worry about manually iterating values or accessing the elements of a data structure. All those would be hidden away in a declarative expression. This is so helpful that the imperative languages have now picked up some style in their syntax from this. Example: two ways of iterating in Java. The second line is the modern form of expression for ( int i = 0 ; i &lt; list.size ( ) ; ++i ) { doSomethingWith ( list.get ( i ) ) ; } for ( SomeType s : list ) { doSomethingWith ( s ) ; } With programs made mostly of pure functions, there‚Äôll be less mutable state to deal with. We can now think in terms of function compositions. Making one function out of others, this is sort of like thinking in terms of space, whereas imperative programming is thinking in terms of time. You don‚Äôt have to worry about concurrent accesses in the functional example, as for each request, it can be served by it‚Äôs own space, without worrying about affecting others. No need to worry about race conditions, deadlocks etc. Example : Scala A simple example in Scala of how easy it is to parallelize stuff in modern functional languages with built-in functionality for parallelism. This code separates a list of people into minors and adults. val people: Array[Person] val (minors, adults) = people partition (_.age &lt; 18) Now the same code parallelized val people: Array[Person] val (minors, adults) = people.par partition (_.age &lt; 18) That‚Äôs it. No worrying about writing the parallelization code, locks, software transactional memory YADA YADA The Functional Renaissance This fundamental compatibility in building concurrent programs has brought back functional programming into the limelight. Now we also have languages that play to the strengths of both the paradigms (Scala). The brevity achieved while writing programs in the recursive way also helps. Done! üéâ Additional resources Martin Odersky, ‚ÄúWorking Hard to Keep It Simple‚Äù - OSCON Java 2011 John Backus‚Äôs Turing Award Lecture John Backus‚Äôs Turing Award Lecture was a watershed for the programming-language community because the inventor of FORTRAN, which was the dominant programming language of the day, stepped forward and said that the main stream of programming practice was flowing in a most unproductive direction. His lecture ‚ÄúCan Programming Be Liberated From the von Neumann Style?‚Äù lambda-the-ultimate Good blog on programming language design FUN FACT Any function that relies on a random number generator cannot be pure ü§î" /> <link rel="canonical" href="https://sreekar.ch/2019/05/28/return-of-functional-programming.html" /> <meta property="og:url" content="https://sreekar.ch/2019/05/28/return-of-functional-programming.html" /> <meta property="og:site_name" content="Musings and digressions" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2019-05-28T00:00:00+05:30" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="The return of functional programming" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sreekar Chigurupati"},"dateModified":"2019-05-28T00:00:00+05:30","datePublished":"2019-05-28T00:00:00+05:30","description":"But first ‚Ä¶ What is functional programming ? Functional programming is a programming paradigm in which most computation is treated as evaluation of functions. It emphasizes on expression evaluation instead of command execution. ‚Äì Wikipedia When did it all start ? In the 90‚Äôs, there was a war between declarative programming and imperative programming. Declarative programming then represented by logic programming languages like Prolog and early functional languages like Erlang. And imperative languages were represented by procedural languages like C and object-oriented languages like Perl. These used abstract data types and procedures (sequence of commands) to compute. You can infer, no doubt that imperative languages won, given the present state of computer languages. One big reason for this is that the process of writing code in an imperative fashion closely mimics the way programs are executed inside the computer. The theoretical basis of the modern computer being the von Neumann computer. Image by Kapooht - Own work, CC BY-SA 3.0, Link As you can see, the von Neumann model is closely mimicked by the execution flow in imperative languages. There is a strong correspondence between mutable variables and memory cells, variable dereferences and load instructions, variable assignments and store instructions, control structures and jumps. This sort of intuition helped programmers adopt them faster. What changed? It‚Äôs time to remember a legend. Gordon Moore. He observed that the number of components on a dense integrated circuit doubles every year. Moore‚Äôs Law Image by Wgsimon - Own work, CC BY-SA 3.0, Link Over the past few years, the trend has subsided as controlling the current flow in the thin channel is becoming more difficult. We cannot make chips smaller anymore, unless there are revolutionary advancements in technology. To keep up with the growing demand for computer power, we‚Äôll have to add more cores on a chip or use more chips. Huge volume workloads that require horizontal scaling are becoming more common. So we‚Äôll have to write software that better gels with the hardware we have. There are two facets to this problem Parallel programming Concurrent programming Parallel programming means using multiple units of hardware to compute something and speed up the process. But the program itself doesn‚Äôt require this, it can still be solved on a single unit of hardware without any loss of functionality apart from speed. Concurrent programming refers to programs that are inherently concurrent - multiple processes executing at the same time, that need to process large number of requests. Eg. Twitter. This has to be done in real-time and cannot be done in a sequential way. While using conventional / imperative programming to implement either of these, we face some fundamental problems. The root of the problem let‚Äôs look at some pseudocode now var x = 0 async { x = x + 1 } async { x = x * 2 } // can give 0, 1, 2 The above program has two asynchronous operations running. We can see that the output is non-deterministic. This non-determinism is caused by concurrent threads accessing shared mutable state. non-determinism = parallel processing + mutable state Out of these, parallel processing can‚Äôt be avoided as our processors aren‚Äôt growing anytime soon. Hence we have to avoid mutable state. The Solution Here come in functional programming and pure functions. When is a function pure? It returns the same result if given the same arguments (it is also referred to as deterministic) It does not cause any observable side effects So functions that use global objects for example would be impure functions. In functional programming, the programmer would no longer have to worry about manually iterating values or accessing the elements of a data structure. All those would be hidden away in a declarative expression. This is so helpful that the imperative languages have now picked up some style in their syntax from this. Example: two ways of iterating in Java. The second line is the modern form of expression for ( int i = 0 ; i &lt; list.size ( ) ; ++i ) { doSomethingWith ( list.get ( i ) ) ; } for ( SomeType s : list ) { doSomethingWith ( s ) ; } With programs made mostly of pure functions, there‚Äôll be less mutable state to deal with. We can now think in terms of function compositions. Making one function out of others, this is sort of like thinking in terms of space, whereas imperative programming is thinking in terms of time. You don‚Äôt have to worry about concurrent accesses in the functional example, as for each request, it can be served by it‚Äôs own space, without worrying about affecting others. No need to worry about race conditions, deadlocks etc. Example : Scala A simple example in Scala of how easy it is to parallelize stuff in modern functional languages with built-in functionality for parallelism. This code separates a list of people into minors and adults. val people: Array[Person] val (minors, adults) = people partition (_.age &lt; 18) Now the same code parallelized val people: Array[Person] val (minors, adults) = people.par partition (_.age &lt; 18) That‚Äôs it. No worrying about writing the parallelization code, locks, software transactional memory YADA YADA The Functional Renaissance This fundamental compatibility in building concurrent programs has brought back functional programming into the limelight. Now we also have languages that play to the strengths of both the paradigms (Scala). The brevity achieved while writing programs in the recursive way also helps. Done! üéâ Additional resources Martin Odersky, ‚ÄúWorking Hard to Keep It Simple‚Äù - OSCON Java 2011 John Backus‚Äôs Turing Award Lecture John Backus‚Äôs Turing Award Lecture was a watershed for the programming-language community because the inventor of FORTRAN, which was the dominant programming language of the day, stepped forward and said that the main stream of programming practice was flowing in a most unproductive direction. His lecture ‚ÄúCan Programming Be Liberated From the von Neumann Style?‚Äù lambda-the-ultimate Good blog on programming language design FUN FACT Any function that relies on a random number generator cannot be pure ü§î","headline":"The return of functional programming","mainEntityOfPage":{"@type":"WebPage","@id":"https://sreekar.ch/2019/05/28/return-of-functional-programming.html"},"url":"https://sreekar.ch/2019/05/28/return-of-functional-programming.html"}</script> <!-- End Jekyll SEO tag --> <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://sreekar.ch/feed.xml" title="Musings and digressions" /> <!-- page to collect tags for indivivual post to display on home --> </head><body><header class="site-header"> <!-- Uncomment for dark mode --> <!-- handling click on dark toggle and setting cookies --> <!-- <script> if(sessionStorage.getItem('theme') === 'dark' || (sessionStorage.getItem('theme') === null && window.matchMedia('(prefers-color-scheme: dark)').matches)) { document.documentElement.classList.toggle('dark'); } function clickHandler() { document.documentElement.classList.toggle('dark'); if (sessionStorage.getItem('theme') === 'light' || (sessionStorage.getItem('theme') === null && !window.matchMedia('(prefers-color-scheme: dark)').matches)) { sessionStorage.setItem('theme', 'dark'); } else { sessionStorage.setItem('theme', 'light'); } } </script> --> <div class="wrapper"><a class="site-title" rel="author" href="/">Musings and digressions</a><nav class="site-nav"> <input type="checkbox" id="nav-trigger" class="nav-trigger" /> <label for="nav-trigger"> <span class="menu-icon"> <svg viewBox="0 0 18 15" width="18px" height="15px"> <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" /> </svg> </span> </label> <div class="trigger"> <!--<a class="page-link" href="/about/">About me</a><a class="page-link" href="/archive/">Blog</a><a class="page-link" href="/categories/">Blog</a><a class="page-link" href="/search">Search</a><a class="page-link" href="/tags/">Blog</a><a class="page-link" href="/talks/">Talks</a>--> <a class="page-link" href="/about">About</a> <a class="page-link" href="/archive">Blog</a> <a class="page-link" href="/talks">Talks</a> <!-- Uncomment for dark mode --> <!-- dark toggle click --> <!-- <a class="page-link" onclick=clickHandler() href="javascript:void(0);">Dark mode</a> --> </div> </nav></div> </header><script src="/assets/js/back-to-top.js"></script> <script>addBackToTop()</script> <main class="page-content" aria-label="Content"> <div class="wrapper"> <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title p-name" itemprop="name headline">The return of functional programming</h1> <p class="post-meta"> <div id="share-bar"> <div class="share-buttons"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> </a> <a href="https://twitter.com/intent/tweet?text=The return of functional programming&url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> </a> <a href="https://www.pinterest.com/pin/create/button/?url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Pinterest" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#pinterest"></use></svg> </a> <a href="http://www.reddit.com/submit?url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Reddit" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#reddit"></use></svg> </a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html&title=The return of functional programming&summary=&source=Musings and digressions" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> </a> <a href="mailto:example@domain.com?subject=The return of functional programming&amp;body=Check out this site https://sreekar.ch/2019/05/28/return-of-functional-programming.html{" title="Share via Email" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#email"></use></svg> </a> </div> </div> <time class="dt-published" datetime="2019-05-28T00:00:00+05:30" itemprop="datePublished">May 28, 2019 </time>‚Ä¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Sreekar Chigurupati</span></span>‚Ä¢ <code>Takes <span class="reading-time" title="Estimated read time"> 6 minutes </span> to read</code><script>(function(root){"use strict";var css=".prBarHeader{width:100%;height:4px;z-index:9999;top:0}.bar{width:0;height:100%;transition:height .3s;background:#000}";function addCss(){var s=document.getElementById("prBarHeadercss");if(s===null){s=document.createElement("style");s.type="text/css";s.id="prBarHeadercss";document.head.insertBefore(s,document.head.firstChild);if(!s.styleSheet)return s.appendChild(document.createTextNode(css));s.styleSheet.cssText=css}}function addClass(el,cls){if(el.classList)el.classList.add(cls);else el.className+=" "+cls}function createBar(rm){var el=document.createElement("div"),width=0,here=0,on=0,bar={el:el,go:go};addClass(el,"bar");function move(){var dist=width-here;if(dist<.1&&dist>-.1){place(here);on=0;if(width>=100){el.style.height=0;setTimeout(function(){rm(el)},300)}}else{place(width-dist/4);setTimeout(go,16)}}function place(num){width=num;el.style.width=width+"%"}function go(num){if(num>=0){here=num;if(!on){on=1;move()}}else if(on){move()}}return bar}function prBarHeader(opts){opts=opts||{};var el=document.createElement("div"),applyGo,prBarHeader={el:el,go:function(p){applyGo(p);if(p>=100){init()}}};function rm(child){el.removeChild(child)}function init(){var bar=createBar(rm);el.appendChild(bar.el);applyGo=bar.go}addCss();addClass(el,"prBarHeader");if(opts.id)el.id=opts.id;if(opts.classname)addClass(el,opts.classname);if(opts.target){el.style.position="relative";opts.target.insertBefore(el,opts.target.firstChild)}else{el.style.position="fixed";document.getElementsByTagName("body")[0].appendChild(el)}init();return prBarHeader}if(typeof exports==="object"){module.exports=prBarHeader}else if(typeof define==="function"&&define.amd){define([],function(){return prBarHeader})}else{root.prBarHeader=prBarHeader}})(this);</script> <script> var options = { classname: 'pr-bar', id: 'prbar-id' }; var prBarHeader = new prBarHeader( options ); prBarHeader.go( 30 ); prBarHeader.go( 76 ); prBarHeader.go(100); </script> <div class="prBarHeader pr-bar" id="prbar-id" style="position: fixed;"> <div class="bar"></div> </div> <style> .progress-bar { background: linear-gradient(to right, #5a8ee2 var(--scroll), transparent 0); background-repeat: no-repeat; width: 100%; position: fixed; top: 0; left: 0; height: 2px; z-index: 1; } </style> <div class="progress-bar"></div> <script> var element = document.documentElement, body = document.body, scrollTop = 'scrollTop', scrollHeight = 'scrollHeight', progress = document.querySelector('.progress-bar'), scroll; document.addEventListener('scroll', function() { scroll = (element[scrollTop]||body[scrollTop]) / ((element[scrollHeight]||body[scrollHeight]) - element.clientHeight) * 100; progress.style.setProperty('--scroll', scroll + '%'); }); </script></p> </header> <div class="post-content e-content" itemprop="articleBody"> <p>But first ‚Ä¶ <img src="/assets/imgs/posts/return-of-functional-programming/arrow.png" alt="Arrow function" /></p> <h2 id="what-is-functional-programming-">What is functional programming ?</h2> <p><img src="/assets/imgs/posts/return-of-functional-programming/lambda.svg" alt="Lambda" width="100px" /></p> <p>Functional programming is a programming paradigm in which most computation is treated as evaluation of functions. It emphasizes on expression evaluation instead of command execution. ‚Äì <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank">Wikipedia</a></p> <h3 id="when-did-it-all-start-">When did it all start ?</h3> <p>In the 90‚Äôs, there was a war between declarative programming and imperative programming. Declarative programming then represented by logic programming languages like Prolog and early functional languages like Erlang. And imperative languages were represented by procedural languages like C and object-oriented languages like Perl. These used abstract data types and procedures (sequence of commands) to compute.</p> <p>You can infer, no doubt that imperative languages won, given the present state of computer languages. One big reason for this is that the process of writing code in an imperative fashion closely mimics the way programs are executed inside the computer. The theoretical basis of the modern computer being the von Neumann computer.</p> <p><img src="/assets/imgs/posts/return-of-functional-programming/von-neumann.svg" alt="von Neumann model" /></p> <p>Image by <a href="//commons.wikimedia.org/w/index.php?title=User:Kapooht&amp;action=edit&amp;redlink=1" class="new" title="User:Kapooht (page does not exist)">Kapooht</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=25789639">Link</a></p> <p>As you can see, the von Neumann model is closely mimicked by the execution flow in imperative languages. There is a strong correspondence between mutable variables and memory cells, variable dereferences and load instructions, variable assignments and store instructions, control structures and jumps. This sort of intuition helped programmers adopt them faster.</p> <h2 id="what-changed">What changed?</h2> <p><img src="/assets/imgs/posts/return-of-functional-programming/rewind-time.jpg" alt="It's rewind time!" /></p> <p>It‚Äôs time to remember a legend. <a href="https://en.wikipedia.org/wiki/Gordon_Moore">Gordon Moore</a>. He observed that the number of components on a dense integrated circuit doubles every year. <a href="https://en.wikipedia.org/wiki/Moore%27s_law">Moore‚Äôs Law</a></p> <p><img src="/assets/imgs/posts/return-of-functional-programming/moores-law.svg" alt="Moore's Law" width="400px" /></p> <p>Image by <a href="//commons.wikimedia.org/wiki/User:Wgsimon" title="User:Wgsimon">Wgsimon</a> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=15193542">Link</a></p> <p>Over the past few years, the trend has subsided as controlling the current flow in the thin channel is becoming more difficult. We cannot make chips smaller anymore, unless there are revolutionary advancements in technology. To keep up with the growing demand for computer power, we‚Äôll have to add more cores on a chip or use more chips. Huge volume workloads that require horizontal scaling are becoming more common. So we‚Äôll have to write software that better gels with the hardware we have.</p> <p>There are two facets to this problem</p> <ul> <li>Parallel programming</li> <li>Concurrent programming</li> </ul> <p>Parallel programming means using multiple units of hardware to compute something and speed up the process. But the program itself doesn‚Äôt require this, it can still be solved on a single unit of hardware without any loss of functionality apart from speed.</p> <p>Concurrent programming refers to programs that are inherently concurrent - multiple processes executing at the same time, that need to process large number of requests. Eg. Twitter. This has to be done in real-time and cannot be done in a sequential way.</p> <p>While using conventional / imperative programming to implement either of these, we face some fundamental problems.</p> <h2 id="the-root-of-the-problem">The root of the problem</h2> <p>let‚Äôs look at some pseudocode now</p> <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">async</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>
<span class="n">async</span> <span class="o">{</span> <span class="n">x</span> <span class="k">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">}</span>  

<span class="c1">// can give 0, 1, 2</span></code></pre></figure> <p>The above program has two asynchronous operations running. We can see that the output is non-deterministic. This non-determinism is caused by concurrent threads accessing shared mutable state.</p> <blockquote> <p>non-determinism = parallel processing + mutable state</p> </blockquote> <p>Out of these, parallel processing can‚Äôt be avoided as our processors aren‚Äôt growing anytime soon. Hence we have to avoid mutable state.</p> <h3 id="the-solution">The Solution</h3> <p><img src="/assets/imgs/posts/return-of-functional-programming/mickey.png" alt="Mickey meme" width="400px" /></p> <p>Here come in functional programming and pure functions.</p> <p>When is a function <code>pure</code>?</p> <ul> <li>It returns the same result if given the same arguments (it is also referred to as deterministic)</li> <li>It does not cause any observable side effects</li> </ul> <p>So functions that use global objects for example would be impure functions.</p> <p>In functional programming, the programmer would no longer have to worry about manually iterating values or accessing the elements of a data structure. All those would be hidden away in a declarative expression. This is so helpful that the imperative languages have now picked up some style in their syntax from this.</p> <p>Example: two ways of iterating in Java. The second line is the modern form of expression</p> <figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span> <span class="o">(</span> <span class="o">)</span> <span class="o">;</span> <span class="o">++</span><span class="n">i</span> <span class="o">)</span> <span class="o">{</span> <span class="n">doSomethingWith</span> <span class="o">(</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span> <span class="o">(</span> <span class="n">i</span> <span class="o">)</span> <span class="o">)</span> <span class="o">;</span> <span class="o">}</span>
<span class="k">for</span> <span class="o">(</span> <span class="nc">SomeType</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span> <span class="o">)</span> <span class="o">{</span> <span class="n">doSomethingWith</span> <span class="o">(</span> <span class="n">s</span> <span class="o">)</span> <span class="o">;</span> <span class="o">}</span></code></pre></figure> <p>With programs made <a href="#rng">mostly</a> of pure functions, there‚Äôll be less mutable state to deal with. We can now think in terms of function compositions. Making one function out of others, this is sort of like thinking in terms of space, whereas imperative programming is thinking in terms of time. You don‚Äôt have to worry about concurrent accesses in the functional example, as for each request, it can be served by it‚Äôs own space, without worrying about affecting others. No need to worry about race conditions, deadlocks etc. <img src="/assets/imgs/posts/return-of-functional-programming/time-space.jpg" alt="Time vs Space" width="400px" /></p> <h3 id="example--scala">Example : Scala</h3> <p>A simple example in Scala of how easy it is to parallelize stuff in modern functional languages with built-in functionality for parallelism. This code separates a list of people into minors and adults.</p> <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nv">people</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">minors</span><span class="o">,</span> <span class="n">adults</span><span class="o">)</span> <span class="k">=</span> <span class="n">people</span> <span class="nf">partition</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">age</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="o">)</span></code></pre></figure> <p>Now the same code parallelized</p> <figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nv">people</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">minors</span><span class="o">,</span> <span class="n">adults</span><span class="o">)</span> <span class="k">=</span> <span class="nv">people</span><span class="o">.</span><span class="py">par</span> <span class="nf">partition</span> <span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">age</span> <span class="o">&lt;</span> <span class="mi">18</span><span class="o">)</span></code></pre></figure> <p>That‚Äôs it. No worrying about writing the parallelization code, locks, software transactional memory YADA YADA</p> <h3 id="the-functional-renaissance">The Functional Renaissance</h3> <p>This fundamental compatibility in building concurrent programs has brought back functional programming into the limelight. Now we also have languages that play to the strengths of both the paradigms (Scala). The brevity achieved while writing programs in the recursive way also helps.</p> <p><strong>Done! üéâ</strong></p> <h3 id="additional-resources">Additional resources</h3> <ul> <li><a href="https://www.youtube.com/watch?v=3jg1AheF4n0" target="_blank">Martin Odersky, ‚ÄúWorking Hard to Keep It Simple‚Äù - OSCON Java 2011</a></li> <li><a href="https://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf" target="_blank">John Backus‚Äôs Turing Award Lecture</a></li> </ul> <p>John Backus‚Äôs Turing Award Lecture was a watershed for the programming-language community because the inventor of FORTRAN, which was the dominant programming language of the day, stepped forward and said that the main stream of programming practice was flowing in a most unproductive direction. His lecture ‚ÄúCan Programming Be Liberated From the von Neumann Style?‚Äù</p> <ul> <li><a href="http://lambda-the-ultimate.org/" target="_blank">lambda-the-ultimate</a> Good blog on programming language design</li> </ul> <h4 id="fun-fact">FUN FACT</h4> <h4 id="-any-function-that-relies-on-a-random-number-generator-cannot-be-pure--"><a name="rng"> Any function that relies on a random number generator cannot be pure ü§î </a></h4> </div> <h4>Share this:</h4> <div id="share-bar"> <div class="share-buttons"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg> </a> <a href="https://twitter.com/intent/tweet?text=The return of functional programming&url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> </a> <a href="https://www.pinterest.com/pin/create/button/?url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Pinterest" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#pinterest"></use></svg> </a> <a href="http://www.reddit.com/submit?url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=900,height=500,toolbar=1,resizable=0'); return false;" title="Share on Reddit" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#reddit"></use></svg> </a> <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://sreekar.ch/2019/05/28/return-of-functional-programming.html&title=The return of functional programming&summary=&source=Musings and digressions" onclick="window.open(this.href, 'pop-up', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> </a> <a href="mailto:example@domain.com?subject=The return of functional programming&amp;body=Check out this site https://sreekar.ch/2019/05/28/return-of-functional-programming.html{" title="Share via Email" > <svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#email"></use></svg> </a> </div> </div><a class="u-url" href="/2019/05/28/return-of-functional-programming.html" hidden></a> </article> </div> </main><footer class="site-footer h-card"> <data class="u-url" href="/"></data> <div class="wrapper"> <div class="footer-col-wrapper"> <div class="footer-col one-half"> <h2 class="footer-heading">Musings and digressions</h2> <ul class="contact-list"> <li class="p-name">Sreekar Chigurupati</li><li><a class="u-email" href="mailto:chigurupatisreekar@gmail.com">chigurupatisreekar@gmail.com</a></li></ul> </div> <div class="footer-col one-half"> <p>Jotting down random thoughts on life and work </p> </div> <div class="social-links"><ul class="social-media-list"><li><a href="https://www.facebook.com/chigurupatisreekar" title="chigurupatisreekar"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#facebook"></use></svg></a></li><li><a href="https://github.com/sreekarchigurupati" title="sreekarchigurupati"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://www.instagram.com/sreekarchigurupati" title="sreekarchigurupati"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#instagram"></use></svg></a></li><li><a href="https://www.linkedin.com/in/sreekar-chigurupati" title="sreekar-chigurupati" data-proofer-ignore><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a href="https://twitter.com/sreekarchiguru" title="sreekarchiguru"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li><li><a href="/feed.xml" title="rss"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul> </div> </div> </div> </footer> </body> </html>
